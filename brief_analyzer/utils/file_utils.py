"""Filename sanitization and file utilities."""

import re
import unicodedata
from pathlib import Path


# Curly/smart quote replacements (per CLAUDE.md)
UNICODE_REPLACEMENTS = {
    "\u2019": "'",   # right single quote -> ASCII apostrophe
    "\u2018": "'",   # left single quote -> ASCII apostrophe
    "\u201c": '"',   # left double quote -> ASCII double quote
    "\u201d": '"',   # right double quote -> ASCII double quote
    "\u2014": "--",  # em dash
    "\u2013": "-",   # en dash
    "\u00a0": " ",   # non-breaking space
}


def sanitize_filename(name: str) -> str:
    """Sanitize a filename by replacing curly quotes and unsafe characters."""
    for old, new in UNICODE_REPLACEMENTS.items():
        name = name.replace(old, new)

    # Remove characters that are problematic in filenames
    name = re.sub(r'[<>:"/\\|?*]', "", name)

    # Collapse multiple spaces
    name = re.sub(r"\s+", " ", name).strip()

    # Truncate to reasonable length (255 bytes max on most filesystems)
    if len(name.encode("utf-8")) > 250:
        base, ext = name.rsplit(".", 1) if "." in name else (name, "")
        while len(f"{base}.{ext}".encode("utf-8")) > 250:
            base = base[:-1]
        name = f"{base}.{ext}" if ext else base

    return name


def safe_rename(src: Path, dst: Path) -> Path:
    """Rename a file, handling conflicts by appending a number."""
    if src == dst:
        return dst

    if not dst.exists():
        src.rename(dst)
        return dst

    # Add a numeric suffix to avoid conflicts
    stem = dst.stem
    suffix = dst.suffix
    counter = 2
    while True:
        candidate = dst.parent / f"{stem} ({counter}){suffix}"
        if not candidate.exists():
            src.rename(candidate)
            return candidate
        counter += 1


# Output files generated by the pipeline -- not briefs
OUTPUT_STEMS = {"AUTHORITIES", "CITECHECK", "ISSUE_ANALYSIS", "MOOT_QA", "SESSION_NOTES", "PROGRESS"}


def _is_output_file(path: Path) -> bool:
    """Check if a file is a pipeline output (not a brief/letter)."""
    return path.stem in OUTPUT_STEMS


# Procedural filing keywords -- these are not substantive briefs
PROCEDURAL_KEYWORDS = {
    "notice", "extension", "information sheet", "letter of assignment",
    "clerks record filed", "reporters record filed", "exhibits filed",
    "hearing record filed", "case began", "case reinstated",
    "record requested", "no reporters record",
}

# Minimum text file size (bytes) to be considered a substantive filing
MIN_BRIEF_SIZE = 10000


def _is_procedural(path: Path) -> bool:
    """Check if a filing is procedural (not a substantive brief/letter)."""
    name_lower = path.stem.lower()
    for kw in PROCEDURAL_KEYWORDS:
        if kw in name_lower:
            return True
    return False


def find_briefs(project_dir: Path) -> list[Path]:
    """Find substantive brief/letter PDF files (not procedural filings)."""
    pdfs = []
    for f in sorted(project_dir.glob("*.pdf")):
        if f.name.startswith(".") or _is_output_file(f) or _is_procedural(f):
            continue
        pdfs.append(f)
    return pdfs


def find_brief_texts(project_dir: Path) -> list[Path]:
    """Find substantive brief/letter .txt files (not procedural filings).

    Filters out pipeline output files, procedural filings by name,
    and files that are too small to be substantive briefs (<10KB).
    """
    txts = []
    for f in sorted(project_dir.glob("*.txt")):
        if f.name.startswith(".") or _is_output_file(f):
            continue
        if _is_procedural(f):
            continue
        if f.stat().st_size < MIN_BRIEF_SIZE:
            continue
        txts.append(f)
    return txts


def find_all_texts(project_dir: Path) -> list[Path]:
    """Find ALL .txt files in the project directory (for authority extraction).

    Unlike find_brief_texts, this includes procedural filings so the
    authority extraction prompt can see everything and decide what's relevant.
    """
    txts = []
    for f in sorted(project_dir.glob("*.txt")):
        if f.name.startswith(".") or _is_output_file(f):
            continue
        txts.append(f)
    return txts
